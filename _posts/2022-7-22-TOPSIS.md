---
title: 第二讲：用熵权法定权重的TOPSIS(优劣解距离法)
layout: post
post-image: "https://alps-images.obs.cn-east-2.myhuaweicloud.com/img/image-20230722185917433.png"
description: 数学建模算法笔记
tags:
- mathematics modeling
- knowledge
---


> **声明：**
>
> 笔记为本人个人整理，参考清风大佬的视频课件，若有错误请指出。


## 适用范围
- 比较的对象一般远大于两个
- 比较的指标往往不只是一个方面
## 具体步骤
1. 将原始矩阵正向化
	
	 | 指标名称         | 指标特点         | 例子                    |
	  | ---------------- | ---------------- | ----------------------- |
	  | 极大型（效益型） | 越大（多）越好   | 成绩、GDP增速、企业利润 |
	  | 极小型（成本型） | 越小（少）越好   | 费用、坏品率、污染程度  |
	  | 中间型           | 越接近某个值越好 | 水质量评估时的PH值      |
	  | 区间型指标       | 落在某个区间最好 | 体温、水中植物营养物量  |
	
	- 极小型 $\rightarrow$ 极大型
	
	  $$
	  \begin{cases}\ max-x,\ 通用\\\ \frac{1}{x},\ 如果所有的元素均为正数\end{cases}
	  $$
	
	- 中间型 $\rightarrow$ 极大型
	  $$
	  M=max\{\abs{x_i-X_{best}}\}, \\\widetilde{x_i}=1-\frac{\abs{x_i-X_{best}}}{M}
	  $$
	
	- 区间型 $\rightarrow$  极大型
	  $$
	  M=max\{a-min\{x_i\},max\{x_i\}-b\},\\\widetilde{x_i}=\begin{cases}1-\frac{a-x_i}{M}\ ,\ x_i<a\\1\ \ \ \ \ \ \ \ \ \ \ \ \ \ ,\ a\leqslant x_i\leqslant b\\1-\frac{x_i-b}{M}\ \ ,\ x_i>b\end{cases}
	  $$

2. 正向化矩阵标准化

	- 将正向化矩阵记作$X$，对其标准化的矩阵记为$Z$，则$Z$为$X$中每个元素/$\sqrt{其所在列的元素的平方和}$：
	
	$$
	z_{ij}=x_{ij}/\sqrt{\sum_{i=1}^{n}{X_{ij}^2}}
	$$
	
	- 如果$Z$矩阵中存在负数，则需要对$X$使用以下的标准化方法重新标准化：
	  $$
	  \widetilde{z_{ij}}=\frac{x_{ij}-min\{x_{1j},x_{2j},\cdots,x_{nj}\}}{max\{x_{ij},x_{2j},\cdots,x_{nj}\}-min\{x_{ij},x_{2j},\cdots,x_{nj}\}}
	  $$
	  
	
3. 计算第$j$项指标下第$i$个样本所占的比重，并将其看作相对熵中用到的概率：
   
    *（各元素值除以该元素所在列的和）*
    $$
    P_{ij}=\frac{\widetilde{z_{ij}}}{\sum_{i=1}^n{\widetilde{z_{ij}}}}
    $$
    
4. 计算每个指标的熵权：
    $$
    e_j=-\frac{1}{\ln n}\sum_{i=1}^n{p_{ij}\ln (p_{ij})}\ (j=1,2,\cdots,m)\\d_j=1-e_j\\W_j=d_j/\sum_{j=1}^m{d_j}\ (j=1,2,\dots,m)
    $$

3. 计算得分并归一化

​	定义最大值$Z^+=(Z_1^+,Z_2^+,\dots,Z_m^+)\\\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ =矩阵每列取最大值组成的行向量$

​	定义最小值$Z^-=(Z_1^-,Z_2^-,\dots,Z_m^-)\\\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ =矩阵每列取最小值组成的行向量$

​	第$i$个评价对象与最大值的距离$D_i^+=\sqrt{\sum_{j=1}^{m}{W_j(Z_j^+-z_{ij})^2}}$

​	第$i$个评价对象与最小值的距离$D_i^-=\sqrt{\sum_{j=1}^{m}{W_j(Z_j^--z_{ij})^2}}$

​	第$i$个评价对象未归一化的得分：$S_i=\frac{D_i^-}{D_i^++D_i^-}$

​	归一化后得分：$\widetilde{S_i}=S_i/\sum_{i=1}^n{S_i}$

## 熵权法

### 定义

- 原理：指标的变异程度越小，所反映的信息量也越少，其对应的权值也应该越低

  > 解释：即越有可能发生的事情（概率越大），信息量越少；越不可能发生的事情（概率越小），信息量越多

- 如何度量信息量的大小？

  信息量用$I$表示，概率用$p$表示，$x$代表事件$X$可能发生的某种情况，$p(x)$表示这种情况发生的概率

  我们可以定义：$I(x)=-\ln (p(x))$

  事件$X$的信息熵：$H(X)=\sum_{i=1}^n{[p(x_i)}I(x_i)]=-\sum_{i=1}^n{[p(x_i)\ln (p(x_i))]}$

- 对于熵权法而言，信息熵越大信息量越小

  因为我们关注的是已有信息，随机变量的信息熵越大，则它的值（内容）能给你补充的信息量越大，而知道这个值前已有的信息量越小

- 对于比赛来说，熵权法可以随便用；

  对于论文来说，熵权法就是扯淡

## 代码

1. ME_TOPSIS.m

   ```matlab
   %% 将数据复制到工作区，并将矩阵命名为X
   %% 判断矩阵是否需要正向化
   [n,m] = size(X);
   judge = input(['这' num2str(m) '个指标是否需要经过正向化处理，需要则输入1，不需要则输入0：']);
   if judge == 1
       Position = input('输入需要正向化处理的列，如：[1,2,3]：');
       disp('输入这些列各自的指标类型（1：极小型，2：中间型，3：区间型），如：[2,1,3]：')
       Type = input('例如：第2列是极小型，第3列是区间型，第6列是中间型，就输入[1,3,2]：');
       for i = 1 : size(Position,2)
           X(:,Position(i)) = Positivization(X(:,Position(i)),Type(i),Position(i));
       end
       disp('正向化后的矩阵 X = ');
       disp(X)
   end
   %% 标准化
   Z = X ./ repmat(sum(X.*X) .^ 0.5, n, 1);
   disp('标准化矩阵Z = ');
   disp(Z)
   %% 计算熵权
   [n,m] = size(Z);
   D = zeros(1,m);  % 初始化保存信息效用值的行向量
   for i = 1:m
       x = Z(:,i);  % 取出第i列的指标
       p = x / sum(x);
       % 注意，p有可能为0，此时计算ln(p)*p时，Matlab会返回NaN，所以这里我们自己定义一个函数
       e = -sum(p .* mylog(p)) / log(n); % 计算信息熵
       D(i) = 1- e; % 计算信息效用值
   end
   W = D ./ sum(D);  % 将信息效用值归一化，得到权重
   %% 判断是否需要增加权重向量
   disp("是否需要增加权重向量，需要输入1，不需要输入0")
   Judge = input('输入是否需要增加权重：');
   if Judge == 1
       weigh = W;
       OK = 0;  % 用来判断用户的输入格式是否正确
       while OK == 0 
           if abs(sum(weigh) - 1)<0.000001 && size(weigh,1) == 1 && size(weigh,2) == m   % 这里要注意浮点数的运算是不精准的。
                OK =1;
           else
               weigh = input('你输入的有误，请重新输入权重行向量: ');
           end
       end
   else
       weigh = ones(1,m) ./ m ; %如果不需要加权重就默认权重都相同，即都为1/m
   end
   %% 算出得分
   D_P = sum([(Z - repmat(max(Z),n,1)) .^ 2 ] .* repmat(weigh,n,1) ,2) .^ 0.5;   % D+ 与最大值的距离向量
   D_N = sum([(Z - repmat(min(Z),n,1)) .^ 2 ] .* repmat(weigh,n,1) ,2) .^ 0.5;   % D- 与最小值的距离向量
   S = D_N ./ (D_P+D_N);    % 未归一化的得分
   disp('最后的得分为：')
   stand_S = S / sum(S)
   [sorted_S,index] = sort(stand_S ,'descend')
   ```

   